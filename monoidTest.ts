/*
    함수형 프로그래밍 주요 원칙 or 개념
        1. 합성 가능해야 한다.
            - 결합 법칙
            
        2. 연산 시 기존의 값이 변경되어서는 안된다.
            - 불변성
            
        3. 자료구조 및 알고리즘(연산)에 대한 추상화가 가능해야한다.
            - 연산 추상화 및 실체화(Reify)로 연산 및 관리가 쉬워야 한다.
            
        4. 병렬 처리가 가능해야 한다.
            - 결합 법칙을 만족하므로 각 연산을 동시 실행하여 그 결과를 결합할 수 있다.
*/

//
//    범주(Category)
//        - 대상(Object)과 사상(Morphism)의 모음
//
//    대상
//        - 일반적으로 집합이 이에 포함되며, 프로그래밍에서는 타입으로 볼 수 있다.
//
//    사상 
//        - 함수 개념을 추상화한 것으로 프로그래밍에서는 함수가 이에 속한다.
//
//    범주의 조건 [1. 항등원, 2. 사상의 연속성, 3. 합성의 결합법칙]
//        1. 각 대상 A에 대해 항등 사상(id_A)가 존재해야 합니다. 이 사상은 A에서 A로 가는 사상입니다.
//            - 대상 A에 대해 자기 자신을 돌려받을 수 있는 항등원이 존재해야 한다. (identity or pure)
//        2. 사상 f: A -> B와 g: B -> C가 주어졌을 때, 이 두 사상의 합성 g ∘ f: A -> C가 존재해야 합니다. 즉, 두 사상을 연결하여 하나의 사상으로 만들 수 있어야 합니다.
//            - 각 사상은 합성할 수 있어야 한다. (composeable)
//        3. 3개의 사상 f, g, h 가 주어졌을 때 [ (f g) h === f (g h) ] 을 만족해야 한다.
//            - 사상간 결합 법칙이 성립해야 한다. (순수 함수여야 한다.)


type Category<T> = {
    // 항등 함수를 나타내는 identity입니다. 입력된 값을 그대로 반환합니다.
    // 범주론에서, 각 대상 A에 대해 항등 사상(id_A)가 존재해야 합니다.
    identity: (x: T) => T;

    // compose는 두 함수 f와 g를 합성하여 새로운 함수를 반환하는 함수입니다.
    // 범주론에서, 사상 f: A -> B와 g: B -> C가 주어졌을 때, 이 두 사상의 합성 g ∘ f: A -> C가 존재해야 합니다.
    /* 합성 함수 로직의 경우 composeTest.js 로직 참고 */
    compose<A, B, C>(f: (x: A) => B, g: (x: B) => C): (x: A) => C; 
}

/* 모노이드 (Monoide) */
/*
    설명 : 아래 조건을 만족하는 대상과 사상의 모음 (일종의 범주)

    조건
        1. 대상
            - 집합 (Set): 원소들의 모음. 예를 들어, 정수 집합, 문자열 집합 등이 있습니다. (프로그래밍 관점에서 타입)
        2. 사상
            - 해당 집합(대상)에 대한 이항 연산(Binary Operation)이 이루어질 수 있다. (덧셈, 뺄셈 등)
            - 모든 원소에 대해 결합 법칙이 이루어져야 한다.
                ※ 결합법칙 성립예시 ex) [1, 2, 3] ===> [((1 + 2) + 3) === (1 + (2 + 3))]
            - 연산에 대한 항등원이 존재해야 한다.
                ※ 덧셈 연산에 대한 항등원은 0 으로 볼 수 있다. ex) 1 + 0 === 0 + 1
*/
type Monoid<T> = {
    identity: ()=>T;
    concat: (a: T, b: T)=>T;
};

const stringMonoid: Monoid<string> = {
    identity: ()=>'',
    concat: (a, b)=>a+b
};

const numberMonoid: Monoid<number> = {
    identity: ()=>0,
    concat: (a, b)=>a+b
};
